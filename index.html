<!DOCTYPE html>
<html>
<head>
    <meta http-equiv="Content-Type" content="text/html" charset="utf-8"/>
    <title>Babylon - Getting Started</title>
    <!--- Link to the last version of BabylonJS --->
    <script src="https://cdn.babylonjs.com/babylon.js"></script>
<!--    <script src="../../lib/babylon.js"></script>-->
    <script src="./utils.js"></script>
    <style>
        html, body {
            overflow: hidden;
            width: 100%;
            height: 100%;
            margin: 0;
            padding: 0;
        }

        #renderCanvas {
            display: block;
            width: min(100vw,100vh);
            height:min(100vw,100vh);
            touch-action: none;
            margin: auto;
        }

    </style>
</head>
<body>
<canvas id="renderCanvas" ></canvas>
<img id="img" src="./assets/code.png" alt="" style="display: none">
<script>
//https://playground.babylonjs.com/#66PS52
let canvas = window.renderCanvas
let engine = new bl.Engine(canvas, true);
let GL = {
    scene: null,
    camera: null
}
let createScene = function () {
    //创建场景
    GL.scene = new bl.Scene(engine);
    GL.scene.useRightHandedSystem = true;
    //创建相机
    // 创建相机的配置项：name, alpha, beta, radius, target position, scene
    GL.camera = new bl.ArcRotateCamera("Camera",
        BABYLON.Tools.ToRadians(45),
        BABYLON.Tools.ToRadians(45),
        10,
        new BABYLON.Vector3(0, 0, 0),
        GL.scene);
    // GL.camera.fov =0.0001
    GL.camera.mode = BABYLON.Camera.ORTHOGRAPHIC_CAMERA;
    // let ratio = window.innerHeight / window.innerWidth; //计算屏幕宽高比
    // GL.camera.orthoLeft = -13; //设置近平面的左侧边界
    // GL.camera.orthoRight = 13; //设置近平面的右侧边界
    // GL.camera.orthoTop = 13*ratio ; //设置近平面的顶部边界
    // GL.camera.orthoBottom = -13 *ratio; //设置近平面的底部边界
    var halfSize = 35;
    GL.camera.orthoLeft = -halfSize;
    GL.camera.orthoRight = halfSize;
    GL.camera.orthoTop = halfSize;
    GL.camera.orthoBottom = -halfSize;

    var zoom = function(factor) {
        GL.camera.orthoLeft *= factor;
        GL.camera.orthoRight *= factor;
        GL.camera.orthoTop *= factor;
        GL.camera.orthoBottom *= factor;
    }

    // 使用鼠标滚轮来缩放
    var mouseWheelInput = function (event) {
        var delta = 0;
        if (event.wheelDelta) {
            delta = event.wheelDelta;
        } else if (event.detail) {
            delta = -event.detail;
        }

        if (delta > 0) {
            zoom(0.9); // 缩小
        } else if (delta < 0) {
            zoom(1.1); // 放大
        }
    }

    window.addEventListener("mousewheel", mouseWheelInput, false);
    window.addEventListener("DOMMouseScroll", mouseWheelInput, false);


    var lastDistance = null;

    var touchStartHandler = function(event) {
        if (event.touches.length == 2) {
            // 当有两个触摸点时，计算它们的距离
            var dx = event.touches[0].pageX - event.touches[1].pageX;
            var dy = event.touches[0].pageY - event.touches[1].pageY;
            lastDistance = Math.sqrt(dx * dx + dy * dy);
        }
    };

    var touchMoveHandler = function(event) {
        if (event.touches.length == 2) {
            // 再次计算触摸点间的距离
            var dx = event.touches[0].pageX - event.touches[1].pageX;
            var dy = event.touches[0].pageY - event.touches[1].pageY;
            var distance = Math.sqrt(dx * dx + dy * dy);

            if (lastDistance) {
                var factor = lastDistance/ distance ;
                zoom(factor);
                lastDistance = distance;
            }
        }
    };

    var touchEndHandler = function(event) {
        lastDistance = null;
    };

// 将事件监听器添加到canvas或者其他合适的元素上
    canvas.addEventListener('touchstart', touchStartHandler, false);
    canvas.addEventListener('touchmove', touchMoveHandler, false);
    canvas.addEventListener('touchend', touchEndHandler, false);



    // 通过设置相机位置来覆盖 alpha, beta, radius
    GL.camera.setPosition(Vec3(200, 300, 200));
    //设置相机时间绑定到画布上，即画布事件会触发相机动作
    GL.camera.attachControl(canvas, true);


    //创建光
    // create a basic light, aiming 0,1,0 - meaning, to the sky
    // let light = new bl.HemisphericLight('light1', Vec3(0, 0, 5), GL.scene);
    // light.intensity = 1

    GL.scene.ambientColor = Color4(1, 1, 1, 1);
    GL.scene.clearColor = Color4(0.6, 0.6, 0.6, 1);

    // let light1 = new BABYLON.PointLight("pointLight", new BABYLON.Vector3(0, 0, 0), GL.scene);

    CreateMesh()
}

function getGrayData(width, height) {
    let _canvas = document.createElement('canvas')

    _canvas.setAttribute('width', width)
    _canvas.setAttribute('height', height)

    let ctx = _canvas.getContext('2d')

    let img = document.querySelector('#img')
    ctx.drawImage(img, 0, 0, width, height)


    //灰度处理
    let imageData = ctx.getImageData(0, 0, width, height)
    let _data = imageData.data

    for (let i = 0; i < _data.length; i += 4) {
        let ava = (_data[i] + _data[i + 1] + _data[i + 2]) / 3
        _data[i] = ava
        _data[i + 1] = ava
        _data[i + 2] = ava
    }
    return _data
}


function CreateMesh() {

    let width = 50, height = 50
    let data = getGrayData(width, height)

    const SPS = new BABYLON.SolidParticleSystem("SPS", GL.scene, {
        useModelMaterial: true
    }); // scene is required
    const sphere = BABYLON.MeshBuilder.CreateBox("s", {size:1});

    SPS.addShape(sphere, data.length / 4); // 80 other spheres

    sphere.dispose(); //free memory

    var myMaterial = new BABYLON.StandardMaterial("myMaterial", GL.scene);//创建一个材质

    // myMaterial.diffuseColor = new BABYLON.Color3(1, 0, 1);//漫反射颜色
    // myMaterial.specularColor = new BABYLON.Color3(1, 0.6, 0.87);//镜面颜色
    // sphere.emissiveColor = new BABYLON.Color3(1, 0, 0);//自发光颜色
    // myMaterial.ambientColor = new BABYLON.Color3(1, 1, 1);//环境光颜色

    // mesh.material = myMaterial;//mesh是之前创建的物体


    const mesh = SPS.buildMesh(); // finally builds and displays the SPS mesh

    let materials = []
    for (let i = 0; i < width; i++) {
        for (let j = 0; j < height; j++) {
            let index = (i * width + j) * 4
            var mat0 = new BABYLON.StandardMaterial("m1", GL.scene);
            mat0.ambientColor = new BABYLON.Color3(
                data[index] / 255,
                data[index + 1] / 255,
                data[index + 2] / 255,
                // 1,
                // 0,
                // 0
            );
            // console.log(data[index],data[index+1],data[index+2])
            materials.push(mat0)
        }
    }
    SPS.setMultiMaterial(materials);

    // initiate particles function
    SPS.initParticles = () => {
        for (let i = 0; i < width; i++) {
            for (let j = 0; j < height; j++) {
                let index = i * width + j
                const particle = SPS.particles[index];

                particle.position.x = (j - width / 2) ;
                particle.position.y = (i - height / 2);
                particle.position.z = BABYLON.Scalar.RandomRange(-25, 25) ;

                particle.materialIndex = index;

                materials.push(mat0)
            }
        }

    };

    // SPS.updateParticle = SPS.initParticles ;
    SPS.initParticles();
    SPS.setParticles();
    SPS.computeSubMeshes();


}

// call the createScene function
createScene();

// run the render loop
engine.runRenderLoop(function () {
    GL.scene.render();
});

//40分 19s
// the canvas/window resize event handler
window.addEventListener('resize', _ => engine.resize());
//1.57.53
</script>
</body>
</html>
